<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>3D Orman RPG ‚Äî Mobil & Masa√ºst√º</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#08121a;color:#fff;overflow:hidden}
  #overlay{
    position: absolute; left:12px; top:12px; z-index:40; 
    background: rgba(0,0,0,0.45); padding:12px; border-radius:10px; 
    min-width:220px;
  }
  #info { font-size:14px; line-height:1.4; }
  #startBtn, #restartBtn {
    display:block; margin-top:8px; padding:10px 14px; border-radius:8px; border:none; cursor:pointer;
    background: linear-gradient(180deg,#2ea7ff,#0066cc); color:#fff; font-weight:600;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  #statusSmall { font-size:12px; opacity:0.9; margin-top:6px; }
  canvas{display:block}

  /* Joystick container */
  #joystick {
    position: fixed; left:18px; bottom:18px; z-index:35; width:140px; height:140px;
    border-radius:50%; touch-action:none;
    display:none; /* mobilde g√∂sterilecek */
  }
  #joyBg {
    position:absolute; width:100%; height:100%; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border: 2px solid rgba(255,255,255,0.06);
  }
  #joyThumb {
    position:absolute; width:54px; height:54px; left:43px; top:43px; border-radius:50%;
    background: rgba(255,255,255,0.12); display:flex; align-items:center; justify-content:center;
    font-size:12px; color:#fff;
    touch-action:none;
  }

  /* camera drag zone */
  #camZone {
    position: fixed; right:8px; bottom:8px; z-index:35; width:42%; height:48%;
    border-radius:12px; background: linear-gradient(180deg, rgba(0,0,0,0.08), rgba(0,0,0,0.02));
    touch-action:none; display:none;
  }

  /* mobile adjustments */
  @media (pointer: coarse) {
    #joystick, #camZone { display:block; }
    #overlay { left:10px; right:10px; top:8px; min-width:unset; }
    #info { font-size:15px; }
    #startBtn { padding:12px 16px; font-size:16px; }
  }
</style>
</head>
<body>
  <div id="overlay">
    <div id="info">
      <strong>Orman RPG ‚Äî Demo</strong><br>
      Gems: <span id="score">0</span> / <span id="winGoal">100</span><br>
      Can: <span id="health">100</span><br>
      Durum: <span id="status">Hazƒ±r</span><br>
    </div>
    <button id="startBtn">Oyunu Ba≈ülat</button>
    <button id="restartBtn" style="display:none;margin-top:6px;background:#ff5f5f;">Tekrar Ba≈ülat</button>
    <div id="statusSmall">Kontroller: WASD veya sol joystick (mobil). Kamera: fare ile bak veya saƒü b√∂lgeyi s√ºr√ºkle.</div>
  </div>

  <div id="joystick" aria-hidden="true">
    <div id="joyBg"></div>
    <div id="joyThumb">‚óè</div>
  </div>
  <div id="camZone" aria-hidden="true"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ---------- AYARLAR ---------- */
const MODEL_PATHS = {
  player: 'models/player.glb',
  tree: 'models/tree.glb',
  enemyCin: 'models/enemy-cin.glb',
  enemyKurt: 'models/enemy-kurt.glb',
  gem: 'models/gem.glb'
};
const SOUND_PATHS = {
  gemCollect: 'sounds/gem.mp3',
  damage: 'sounds/damage.mp3',
  ambient: 'sounds/ambient.mp3',
  win: 'sounds/win.mp3',
  gameover: 'sounds/gameover.mp3'
};

const WIN_SCORE = 100;
const GEM_COUNT = 25;
const ENEMY_COUNT = 8;
const PLAYER_MAX_HEALTH = 100;
const PLAYER_BASE_SPEED = 6.0;

/* ---------- GLOBALS ---------- */
let scene, camera, renderer, clock;
let player, controls;
let loadedModels = {}, sounds = {};
let gems = [], trees = [], enemies = [];
let gemsCollected = 0, health = PLAYER_MAX_HEALTH;
let isRunning = false;
let isPointerLocked = false;
let statusEl, scoreEl, healthEl, winGoalEl, startBtn, restartBtn;
let listener;
let move = { forward:0, right:0 };
let playerLastHurt = -999;
const PLAYER_INVULN = 1.0;

/* ---------- UTILS ---------- */
const $ = id => document.getElementById(id);
function rand(min,max){ return min + Math.random()*(max-min); }

/* ---------- INIT ---------- */
function init(){
  statusEl = $('status'); scoreEl = $('score'); healthEl = $('health'); winGoalEl = $('winGoal'); startBtn = $('startBtn'); restartBtn = $('restartBtn');
  winGoalEl.textContent = WIN_SCORE;

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x9bd3ff);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,1.6,6);

  listener = new THREE.AudioListener();
  camera.add(listener);

  const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.7); hemi.position.set(0,50,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(5,20,10); dir.castShadow=true; scene.add(dir);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1e6b2e}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  player = new THREE.Object3D(); player.position.set(0,1,0); scene.add(player);

  controls = new THREE.PointerLockControls( camera, document.body );
  controls.addEventListener('lock', () => { isPointerLocked = true; statusEl.textContent = 'Pointer kilitlendi - oyun ba≈ülƒ±yor'; });
  controls.addEventListener('unlock', () => { isPointerLocked = false; statusEl.textContent = 'Pointer a√ßƒ±ldƒ±'; });

  window.addEventListener('resize', onWindowResize, false);
  attachInputHandlers();

  clock = new THREE.Clock();

  // y√ºkle
  loadAllAssets().then(setupWorld).catch(err => { console.warn(err); setupWorld(); });
}

/* ---------- ASSET Y√úKLEME ---------- */
function loadGLTF(url){ return new Promise((res,rej) => { const loader = new THREE.GLTFLoader(); loader.load(url, g => res(g.scene), undefined, err => rej(err)); }); }
function loadAudioBuffer(url){ return new Promise((res,rej) => { const al = new THREE.AudioLoader(); al.load(url, buff => res(buff), undefined, err => rej(err)); }); }

async function loadAllAssets(){
  const tasks = [];
  for (const [k,p] of Object.entries(MODEL_PATHS)){
    tasks.push(loadGLTF(p).then(o => loadedModels[k] = o).catch(e => { console.warn('Model y√ºklenemedi',p); loadedModels[k]=null; }));
  }
  for (const [k,p] of Object.entries(SOUND_PATHS)){
    tasks.push(loadAudioBuffer(p).then(buf => { const a = new THREE.Audio(listener); a.setBuffer(buf); if (k==='ambient') a.setLoop(true); sounds[k]=a; }).catch(e => { console.warn('Ses y√ºklenemedi',p); sounds[k]=null; }));
  }
  return Promise.all(tasks);
}

/* ---------- D√úNYA KURULUMU ---------- */
function setupWorld(){
  // player model fallback
  if (loadedModels.player){ const pm = loadedModels.player.clone(); pm.traverse(n => n.isMesh && (n.castShadow = true)); player.add(pm); } 
  else { const m = new THREE.Mesh(new THREE.CapsuleGeometry(0.4,0.8,4,8), new THREE.MeshStandardMaterial({color:0x0077ff})); m.castShadow=true; player.add(m); }

  // trees
  for (let i=0;i<40;i++){
    const x=rand(-45,45), z=rand(-45,45);
    let t;
    if (loadedModels.tree){ t = loadedModels.tree.clone(); t.scale.setScalar(rand(0.8,1.4)); }
    else { t = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.6,3,8), new THREE.MeshStandardMaterial({color:0x654321})); const leaf=new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8), new THREE.MeshStandardMaterial({color:0x2e8b57})); leaf.position.y=1.8; t.add(leaf); }
    t.position.set(x,0,z); t.userData = { _playerInside:false }; t.castShadow=true; scene.add(t); trees.push(t);
  }

  // gems
  for (let i=0;i<GEM_COUNT;i++){
    const x=rand(-40,40), z=rand(-40,40);
    let g;
    if (loadedModels.gem){ g = loadedModels.gem.clone(); g.scale.setScalar(0.6); } 
    else { g = new THREE.Mesh(new THREE.OctahedronGeometry(0.35), new THREE.MeshStandardMaterial({emissive: new THREE.Color(0x00ffcc), metalness:0.25})); }
    g.position.set(x,0.6,z); g.userData = { value: Math.round(rand(3,5)) }; scene.add(g); gems.push(g);
  }

  createEnemies();

  // ambient start only after user gesture ‚Äî will be started on startBtn click
  updateUI();
  animate();
}

/* ---------- ENEMIES ---------- */
function createEnemies(){
  enemies.forEach(e => scene.remove(e));
  enemies = [];
  for (let i=0;i<ENEMY_COUNT;i++){
    const type = Math.random()>0.5 ? 'kurt' : 'cin';
    let e;
    if (type==='cin' && loadedModels.enemyCin){ e = loadedModels.enemyCin.clone(); e.scale.setScalar(0.9); }
    else if (type==='kurt' && loadedModels.enemyKurt){ e = loadedModels.enemyKurt.clone(); e.scale.setScalar(0.9); }
    else { e = new THREE.Mesh(new THREE.SphereGeometry(0.6,12,12), new THREE.MeshStandardMaterial({color: type==='kurt' ? 0x333333 : 0x2e8b57})); }
    e.position.set(rand(-40,40),0.6,rand(-40,40)); e.castShadow=true;
    e.userData = {
      type, baseSpeed: type==='kurt' ? 2.2 : 1.5, speed:0, damage: type==='kurt' ? 12 : 6,
      detectionRadius: type==='kurt' ? 8:12, attackCooldown:1.2, lastAttack:-999,
      patrolDir: new THREE.Vector3(rand(-1,1),0,rand(-1,1)).normalize(),
      lastSprint:-999, sprintCooldown:5+Math.random()*6, lastTeleport:-999, teleportCooldown:6+Math.random()*8
    };
    enemies.push(e); scene.add(e);
  }
}

function updateEnemies(delta){
  const elapsed = clock.getElapsedTime();
  const difficultyScale = 1 + (gemsCollected / 50) + (elapsed / 120);
  enemies.forEach(enemy => {
    enemy.userData.speed = enemy.userData.baseSpeed * difficultyScale;
    const toPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
    const dist = toPlayer.length();
    if (dist < enemy.userData.detectionRadius){
      if (enemy.userData.type === 'kurt'){
        if (elapsed - enemy.userData.lastSprint > enemy.userData.sprintCooldown && Math.random() < 0.25){
          enemy.userData.lastSprint = elapsed;
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(enemy.userData.speed * 3);
        } else {
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(enemy.userData.speed);
        }
      } else {
        if (dist > 6){
          if (elapsed - enemy.userData.lastTeleport > enemy.userData.teleportCooldown && Math.random() < 0.06){
            enemy.userData.lastTeleport = elapsed;
            const angle = Math.random()*Math.PI*2;
            const offset = new THREE.Vector3(Math.cos(angle)*2 + rand(-1,1), 0, Math.sin(angle)*2 + rand(-1,1));
            enemy.position.copy(player.position).add(offset);
          }
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(enemy.userData.speed * 0.9);
        } else {
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(-enemy.userData.speed*0.5);
        }
      }
    } else {
      if (!enemy.userData.velocity || enemy.userData.velocity.length() < 0.01){
        enemy.userData.velocity = enemy.userData.patrolDir.clone().multiplyScalar(enemy.userData.speed*0.4);
      }
      if (Math.random() < 0.004) {
        enemy.userData.patrolDir = new THREE.Vector3(rand(-1,1),0,rand(-1,1)).normalize();
        enemy.userData.velocity = enemy.userData.patrolDir.clone().multiplyScalar(enemy.userData.speed*0.4);
      }
    }

    if (enemy.userData.velocity) enemy.position.add(enemy.userData.velocity.clone().multiplyScalar(delta));
    enemy.position.x = THREE.MathUtils.clamp(enemy.position.x, -48, 48);
    enemy.position.z = THREE.MathUtils.clamp(enemy.position.z, -48, 48);
    enemy.rotation.y += delta * 0.5 * (enemy.userData.type === 'kurt' ? 1.4 : 0.8);
  });
}

/* ---------- PLAYER G√úNCELLEME ---------- */
function updatePlayer(delta){
  const elapsed = clock.getElapsedTime();
  let moveSpeed = PLAYER_BASE_SPEED;
  if (player.userData && player.userData.slowUntil && elapsed < player.userData.slowUntil) moveSpeed *= 0.45;

  const velocity = new THREE.Vector3();
  if (move.forward !== 0) {
    const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
    velocity.add(dir.multiplyScalar(move.forward));
  }
  if (move.right !== 0) {
    const right = new THREE.Vector3(); camera.getWorldDirection(right); right.y = 0; right.normalize(); right.cross(camera.up);
    velocity.add(right.multiplyScalar(move.right));
  }

  if (velocity.length() > 0) {
    velocity.normalize();
    player.position.add(velocity.multiplyScalar(moveSpeed * delta));
  }
  camera.position.copy(player.position).add(new THREE.Vector3(0,1.6,0));
  player.position.x = THREE.MathUtils.clamp(player.position.x, -49, 49);
  player.position.z = THREE.MathUtils.clamp(player.position.z, -49, 49);
}

/* ---------- √áARPI≈ûMA ---------- */
function checkCollisions(){
  const elapsed = clock.getElapsedTime();
  enemies.forEach(enemy => {
    if (enemy.position.distanceTo(player.position) < 1.4){
      if (elapsed - playerLastHurt > PLAYER_INVULN && elapsed - enemy.userData.lastAttack > enemy.userData.attackCooldown){
        let damage = Math.round(enemy.userData.damage * (1 + gemsCollected/100));
        health -= damage; enemy.userData.lastAttack = elapsed; playerLastHurt = elapsed;
        if (sounds.damage){ try { sounds.damage.setVolume(0.9); sounds.damage.play(); } catch(e){} }
        updateUI();
        if (health <= 0) gameOver();
      }
    }
  });

  trees.forEach(tree => {
    const dist = tree.position.distanceTo(player.position);
    if (!tree.userData._playerInside && dist < 2.0){
      tree.userData._playerInside = true; health -= 6;
      player.userData = player.userData || {};
      player.userData.slowUntil = clock.getElapsedTime() + 2.0;
      if (sounds.damage){ try { sounds.damage.setVolume(0.6); sounds.damage.play(); } catch(e){} }
      updateUI();
      if (health <= 0) gameOver();
    } else if (tree.userData._playerInside && dist >= 2.4){
      tree.userData._playerInside = false;
    }
  });

  for (let i=gems.length-1;i>=0;i--){
    const g = gems[i];
    if (g.position.distanceTo(player.position) < 1.2){
      gemsCollected += g.userData.value || 4;
      scene.remove(g); gems.splice(i,1);
      if (sounds.gemCollect){ try { sounds.gemCollect.setVolume(0.9); sounds.gemCollect.play(); } catch(e){} }
      updateUI();
      if (gemsCollected >= WIN_SCORE) gameWon();
    }
  }
}

/* ---------- OYUN SONU ---------- */
function gameWon(){
  isRunning = false; statusEl.textContent = 'Kazandƒ±n! üéâ'; controls.unlock();
  if (sounds.win){ try { sounds.win.setVolume(0.9); sounds.win.play(); } catch(e){} }
  $('restartBtn').style.display='block';
}
function gameOver(){
  isRunning = false; statusEl.textContent = 'Oyunu kaybettin.'; controls.unlock();
  if (sounds.gameover){ try { sounds.gameover.setVolume(0.9); sounds.gameover.play(); } catch(e){} }
  $('restartBtn').style.display='block';
}

/* ---------- UI ---------- */
function updateUI(){ scoreEl.textContent = gemsCollected; healthEl.textContent = Math.max(0, Math.round(health)); }

/* ---------- ANIMATE ---------- */
function animate(){
  requestAnimationFrame(animate);
  const delta = Math.min(0.05, clock.getDelta());
  if (isRunning){
    updatePlayer(delta);
    updateEnemies(delta);
    checkCollisions();
  } else {
    // kamera player'ƒ± takip et
    camera.position.copy(player.position).add(new THREE.Vector3(0,1.6,0));
  }
  gems.forEach(g => g.rotation.y += 0.8 * delta);
  renderer.render(scene, camera);
}

/* ---------- Gƒ∞Rƒ∞≈û / KONTROLLER ---------- */
function onWindowResize(){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

function attachInputHandlers(){
  // klavye
  window.addEventListener('keydown', e => {
    if (e.code === 'KeyW') move.forward = 1;
    if (e.code === 'KeyS') move.forward = -1;
    if (e.code === 'KeyA') move.right = -1;
    if (e.code === 'KeyD') move.right = 1;
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'KeyW' || e.code === 'KeyS') move.forward = 0;
    if (e.code === 'KeyA' || e.code === 'KeyD') move.right = 0;
  });

  // pointer lock + start
  startBtn.addEventListener('click', async () => {
    // startGame √ßaƒürƒ±sƒ± kesinlikle burada
    await startGame(); // ses ve deƒüi≈ükenler start ile ba≈ülatƒ±lƒ±r
    // pointer lock destekliyorsa iste
    try {
      controls.lock();
    } catch(e){}
  });

  restartBtn.addEventListener('click', () => {
    location.reload(); // basit ve g√ºvenli
  });

  // fare & dokunmatik kamera kontrol (saƒü alt alan)
  const camZone = $('camZone');
  let camTouch = null;
  let prevCam = null;

  const startCamDrag = (clientX, clientY) => { camTouch = {x:clientX, y:clientY}; prevCam = {x:clientX, y:clientY}; };
  const moveCamDrag = (clientX, clientY) => {
    if (!camTouch) return;
    const dx = (clientX - prevCam.x) * 0.0025;
    const dy = (clientY - prevCam.y) * 0.0025;
    // apply to controls or camera directly
    camera.rotation.y -= dx;
    camera.rotation.x = Math.max(-1.2, Math.min(1.2, camera.rotation.x - dy));
    prevCam = {x:clientX, y:clientY};
  };
  const endCamDrag = () => { camTouch = null; prevCam = null; };

  // mouse events for desktop drag on camZone
  camZone.addEventListener('mousedown', e => { e.preventDefault(); startCamDrag(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e => { if (camTouch) moveCamDrag(e.clientX, e.clientY); });
  window.addEventListener('mouseup', endCamDrag);

  // touch events
  camZone.addEventListener('touchstart', e => { const t = e.changedTouches[0]; startCamDrag(t.clientX, t.clientY); }, {passive:false});
  camZone.addEventListener('touchmove', e => { const t = e.changedTouches[0]; moveCamDrag(t.clientX, t.clientY); }, {passive:false});
  camZone.addEventListener('touchend', endCamDrag);

  // virtual joystick (mobil)
  setupJoystick();
}

/* ---------- JOYSTICK ---------- */
function setupJoystick(){
  const joy = $('joystick');
  const thumb = $('joyThumb');
  const bg = $('joyBg');
  let active = false;
  let startX=0, startY=0;
  const maxDist = 44; // px

  const touchStart = (x,y) => {
    active = true; startX = x; startY = y;
    thumb.style.transition = 'none';
  };
  const touchMove = (x,y) => {
    if (!active) return;
    const dx = x - startX, dy = y - startY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const clamped = Math.min(maxDist, dist);
    const angle = Math.atan2(dy, dx);
    const tx = Math.cos(angle) * clamped, ty = Math.sin(angle)*clamped;
    thumb.style.transform = `translate(${tx}px, ${ty}px)`;
    // normalize to [-1,1]
    const nx = tx / maxDist;
    const ny = ty / maxDist;
    // forward is -y (up moves forward)
    move.forward = -(Math.round(ny*100)/100);
    move.right = Math.round(nx*100)/100;
  };
  const touchEnd = () => {
    active = false;
    thumb.style.transition = 'transform 0.12s ease'; thumb.style.transform = `translate(0px,0px)`;
    move.forward = 0; move.right = 0;
  };

  // mouse for debug / desktop
  thumb.addEventListener('mousedown', e => { e.preventDefault(); touchStart(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e => { if (active) touchMove(e.clientX, e.clientY); });
  window.addEventListener('mouseup', () => { if (active) touchEnd(); });

  // touch
  joy.addEventListener('touchstart', e => { const t = e.changedTouches[0]; touchStart(t.clientX, t.clientY); }, {passive:false});
  joy.addEventListener('touchmove', e => { const t = e.changedTouches[0]; touchMove(t.clientX, t.clientY); }, {passive:false});
  joy.addEventListener('touchend', e => { touchEnd(); }, {passive:false});
}

/* ---------- START GAME (SON DERECE √ñNEMLƒ∞: ba≈ülatma mantƒ±ƒüƒ±) ---------- */
async function startGame(){
  // prevent double start
  if (isRunning) return;
  // reset variables
  gemsCollected = 0; health = PLAYER_MAX_HEALTH; isRunning = true;
  $('startBtn').style.display = 'none';
  $('restartBtn').style.display = 'none';
  statusEl.textContent = 'Oyun ba≈üladƒ±';
  updateUI();
  // play ambient (must be user gesture)
  try { if (sounds.ambient) { sounds.ambient.setVolume(0.25); sounds.ambient.play(); } } catch(e){ console.warn('ambient play error',e); }
  // ensure mobile controls visible if touch device
  if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches){
    $('joystick').style.display = 'block';
    $('camZone').style.display = 'block';
  } else {
    $('joystick').style.display = 'none';
    $('camZone').style.display = 'none';
  }
}

/* ---------- STARTUP ---------- */
init();

/* ---------- RESTART BUTTON SHOWING HANDLED IN gameOver / gameWon ---------- */

</script>
</body>
</html>
