<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Orman RPG â€” Demo</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
  #overlay{
    position: absolute;left:12px;top:12px;z-index:10;color:#fff;
    background: rgba(0,0,0,0.35);padding:10px;border-radius:8px;
  }
  #info { font-size:14px; line-height:1.4; }
  #startBtn{display:block;margin-top:8px;padding:8px 12px;border-radius:6px;background:#2d8cff;color:#fff;border:none;cursor:pointer}
  canvas{display:block}
</style>
</head>
<body>
<div id="overlay">
  <div id="info">
    <strong>Orman RPG (demo)</strong><br>
    Gems: <span id="score">0</span> / <span id="winGoal">100</span><br>
    Can: <span id="health">100</span><br>
    Durum: <span id="status">Bekleniyor</span>
  </div>
  <button id="startBtn">Oyunu BaÅŸlat</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
/*
  3D Orman RPG - index.html
  - Asset yollarÄ±: models/*.glb ve sounds/*.mp3 (aÅŸaÄŸÄ±da listelenmiÅŸtir)
  - Bu dosya: tÃ¼m oyun dÃ¶ngÃ¼sÃ¼nÃ¼, asset yÃ¼klemesini, dÃ¼ÅŸman davranÄ±ÅŸlarÄ±nÄ±, collision mantÄ±ÄŸÄ±nÄ± iÃ§erir.
*/

// ------------------- AYARLAR / SABÄ°TLER -------------------
const MODEL_PATHS = {
  player: 'models/player.glb',
  tree: 'models/tree.glb',
  enemyCin: 'models/enemy-cin.glb',
  enemyKurt: 'models/enemy-kurt.glb',
  gem: 'models/gem.glb'
};

const SOUND_PATHS = {
  gemCollect: 'sounds/gem.mp3',
  damage: 'sounds/damage.mp3',
  ambient: 'sounds/ambient.mp3',
  win: 'sounds/win.mp3',
  gameover: 'sounds/gameover.mp3'
};

const WIN_SCORE = 100;
const GEM_COUNT = 25;
const ENEMY_COUNT = 8;
const PLAYER_MAX_HEALTH = 100;
const PLAYER_BASE_SPEED = 6.0; // birim / saniye

// ------------------- GLOBALLER -------------------
let scene, camera, renderer, clock;
let player, controls;
let loadedModels = {};
let sounds = {};
let gems = [];
let trees = [];
let enemies = [];
let gemsCollected = 0;
let health = PLAYER_MAX_HEALTH;
let statusEl, scoreEl, healthEl, winGoalEl, startBtn;
let listener;
let isRunning = false;

// ------------------- BASÄ°T YARDIMCILER -------------------
function $(id){ return document.getElementById(id); }
function rand(min,max){ return min + Math.random()*(max-min); }

// ------------------- INIT -------------------
function init() {
  // DOM elemanlarÄ±
  statusEl = $('status'); scoreEl = $('score'); healthEl = $('health'); winGoalEl = $('winGoal'); startBtn = $('startBtn');
  winGoalEl.textContent = WIN_SCORE;

  // Renderer + Scene
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x9bd3ff); // hafif gÃ¶kyÃ¼zÃ¼
  clock = new THREE.Clock();

  // Camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 6);

  // Audio listener
  listener = new THREE.AudioListener();
  camera.add(listener);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
  hemi.position.set(0, 50, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(5, 20, 10);
  dir.castShadow = true;
  dir.shadow.camera.top = 10; dir.shadow.camera.bottom = -10;
  dir.shadow.camera.left = -10; dir.shadow.camera.right = 10;
  scene.add(dir);

  // Ground (simple)
  const groundGeo = new THREE.PlaneGeometry(200,200);
  const groundMat = new THREE.MeshStandardMaterial({ color:0x1e6b2e });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Player placeholder (position & logical object)
  player = new THREE.Object3D();
  player.position.set(0, 1.0, 0);
  scene.add(player);

  // Controls (pointer lock)
  controls = new THREE.PointerLockControls(camera, document.body);
  startBtn.addEventListener('click', () => {
    controls.lock();
    if (!isRunning) startGame();
  });
  controls.addEventListener('lock', () => {
    statusEl.textContent = 'Oyun baÅŸladÄ±';
  });
  controls.addEventListener('unlock', () => {
    statusEl.textContent = 'Durdu (pointer unlock)';
  });

  // Resize handler
  window.addEventListener('resize', onWindowResize, false);

  // Start asset loading
  loadAllAssets().then(setupWorld).catch(err => {
    console.error('Asset yÃ¼kleme hatasÄ±:', err);
    setupWorld(); // yine de dene
  });
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ------------------- ASSET YÃœKLEME -------------------
function loadGLTF(url){
  return new Promise((res, rej) => {
    const loader = new THREE.GLTFLoader();
    loader.load(url, gltf => res(gltf.scene), err => rej(err));
  });
}

function loadAudioBuffer(url){
  return new Promise((resolve, reject) => {
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load(url, buffer => resolve(buffer), undefined, err => reject(err));
  });
}

async function loadAllAssets(){
  const promises = [];
  // Modeller
  for (const [k, path] of Object.entries(MODEL_PATHS)){
    promises.push(
      loadGLTF(path).then(obj => { loadedModels[k] = obj; }).catch(err => {
        console.warn('Model yÃ¼klenemedi:', path, err);
        loadedModels[k] = null; // fallback
      })
    );
  }

  // Sesler
  for (const [k, path] of Object.entries(SOUND_PATHS)){
    promises.push(
      loadAudioBuffer(path).then(buffer => {
        const audio = new THREE.Audio(listener);
        audio.setBuffer(buffer);
        // loop ambiyans haricinde auto play kontrolÃ¼ oyunun baÅŸÄ±nda yapÄ±lÄ±r
        if (k === 'ambient') audio.setLoop(true);
        sounds[k] = audio;
      }).catch(err => {
        console.warn('Ses yÃ¼klenemedi:', path, err);
        sounds[k] = null;
      })
    );
  }

  return Promise.all(promises);
}

// ------------------- DÃœNYA KURULUMU (MODELS -> sahne yerleÅŸtirme) -------------------
function setupWorld() {
  // Player model (optional)
  if (loadedModels.player){
    const pm = loadedModels.player.clone();
    pm.scale.setScalar(1.0);
    pm.traverse(n => { if (n.isMesh) n.castShadow = true; });
    player.add(pm);
  } else {
    // fallback simple capsule
    const mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.8, 4, 8), new THREE.MeshStandardMaterial({color:0x0077ff}));
    mesh.castShadow = true;
    player.add(mesh);
  }

  // Trees
  for (let i=0;i<40;i++){
    const x = rand(-45,45), z = rand(-45,45);
    let tree;
    if (loadedModels.tree){
      tree = loadedModels.tree.clone();
      tree.scale.setScalar(rand(0.8,1.4));
    } else {
      tree = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.6,3,8), new THREE.MeshStandardMaterial({color:0x654321}));
      const leaf = new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8), new THREE.MeshStandardMaterial({color:0x2e8b57}));
      leaf.position.y = 1.8; tree.add(leaf);
    }
    tree.position.set(x, 0.0, z);
    tree.castShadow = true;
    tree.userData = tree.userData || {};
    tree.userData._playerInside = false;
    trees.push(tree);
    scene.add(tree);
  }

  // Gems
  for (let i=0;i<GEM_COUNT;i++){
    const x = rand(-40,40), z = rand(-40,40);
    let gem;
    if (loadedModels.gem){
      gem = loadedModels.gem.clone();
      gem.scale.setScalar(0.6);
    } else {
      gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.35), new THREE.MeshStandardMaterial({emissive: new THREE.Color(0x00ffcc), metalness:0.3}));
    }
    gem.position.set(x, 0.6, z);
    gem.userData = { value: Math.round(rand(3,5)) };
    gems.push(gem);
    scene.add(gem);
  }

  // Enemies
  createEnemies();

  // Play ambient if loaded
  if (sounds.ambient) {
    sounds.ambient.setVolume(0.25);
    sounds.ambient.play();
  }

  // UI update
  updateUI();

  // Start render loop (but game starts on pointer lock)
  animate();
}

// ------------------- OYUN BAÅžLAMA / DURUM -------------------
function startGame() {
  isRunning = true;
  gemsCollected = 0;
  health = PLAYER_MAX_HEALTH;
  scoreEl.textContent = gemsCollected;
  healthEl.textContent = health;
  statusEl.textContent = 'Oyun Ã§alÄ±ÅŸÄ±yor';
  // reset objects: remove extra enemies/gems if needed (simple approach: reload scene)
  // (burada mevcut scene Ã¶ÄŸeleri korunur)
}

// ------------------- DÃœÅžMAN OLUÅžTURMA / GÃœNCELLEME -------------------
function createEnemies(){
  enemies.forEach(e => scene.remove(e));
  enemies = [];
  for (let i = 0; i < ENEMY_COUNT; i++){
    const type = Math.random() > 0.5 ? 'kurt' : 'cin';
    let e;
    if (type === 'cin' && loadedModels.enemyCin){
      e = loadedModels.enemyCin.clone();
      e.scale.setScalar(0.9);
    } else if (type === 'kurt' && loadedModels.enemyKurt){
      e = loadedModels.enemyKurt.clone();
      e.scale.setScalar(0.9);
    } else {
      const c = type === 'kurt' ? 0x333333 : 0x2e8b57;
      e = new THREE.Mesh(new THREE.SphereGeometry(0.6,12,12), new THREE.MeshStandardMaterial({color:c}));
    }
    e.position.set(rand(-40,40), 0.6, rand(-40,40));
    e.castShadow = true;
    e.userData = {
      type: type,
      baseSpeed: type === 'kurt' ? 2.2 : 1.5,
      speed: 0,
      damage: type === 'kurt' ? 12 : 6,
      detectionRadius: type === 'kurt' ? 8 : 12,
      attackCooldown: 1.2,
      lastAttack: -999,
      patrolDir: new THREE.Vector3(rand(-1,1),0,rand(-1,1)).normalize(),
      lastSprint: -999,
      sprintCooldown: 5 + Math.random()*6,
      lastTeleport: -999,
      teleportCooldown: 6 + Math.random()*8
    };
    enemies.push(e);
    scene.add(e);
  }
}

function updateEnemies(delta){
  const elapsed = clock.getElapsedTime();
  const difficultyScale = 1 + (gemsCollected / 50) + (elapsed / 120);

  enemies.forEach(enemy => {
    enemy.userData.speed = enemy.userData.baseSpeed * difficultyScale;
    const toPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
    const dist = toPlayer.length();

    if (dist < enemy.userData.detectionRadius){
      // detected player
      if (enemy.userData.type === 'kurt'){
        // chase + possible sprint
        if (elapsed - enemy.userData.lastSprint > enemy.userData.sprintCooldown && Math.random() < 0.25){
          enemy.userData.lastSprint = elapsed;
          const sprintVel = toPlayer.clone().normalize().multiplyScalar(enemy.userData.speed * 3);
          enemy.userData.velocity = sprintVel;
        } else {
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(enemy.userData.speed);
        }
      } else {
        // cin: teleport sometimes if far; if near, pulse/retreat
        if (dist > 6){
          if (elapsed - enemy.userData.lastTeleport > enemy.userData.teleportCooldown && Math.random() < 0.06){
            enemy.userData.lastTeleport = elapsed;
            const angle = Math.random()*Math.PI*2;
            const offset = new THREE.Vector3(Math.cos(angle)*2 + rand(-1,1), 0, Math.sin(angle)*2 + rand(-1,1));
            enemy.position.copy(player.position).add(offset);
          }
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(enemy.userData.speed * 0.9);
        } else {
          enemy.userData.velocity = toPlayer.clone().normalize().multiplyScalar(-enemy.userData.speed*0.5);
        }
      }
    } else {
      // patrol
      if (!enemy.userData.velocity || enemy.userData.velocity.length() < 0.01){
        enemy.userData.velocity = enemy.userData.patrolDir.clone().multiplyScalar(enemy.userData.speed*0.4);
      }
      if (Math.random() < 0.004) {
        enemy.userData.patrolDir = new THREE.Vector3(rand(-1,1),0,rand(-1,1)).normalize();
        enemy.userData.velocity = enemy.userData.patrolDir.clone().multiplyScalar(enemy.userData.speed*0.4);
      }
    }

    if (enemy.userData.velocity) enemy.position.add(enemy.userData.velocity.clone().multiplyScalar(delta));

    // bounds
    if (Math.abs(enemy.position.x) > 48) enemy.position.x = THREE.MathUtils.clamp(enemy.position.x, -48, 48);
    if (Math.abs(enemy.position.z) > 48) enemy.position.z = THREE.MathUtils.clamp(enemy.position.z, -48, 48);

    // small rotate to feel alive
    enemy.rotation.y += delta * 0.5 * (enemy.userData.type === 'kurt' ? 1.4 : 0.8);
  });
}

// ------------------- PLAYER GÃœNCELLEME -------------------
let move = { forward:0, right:0 };
let playerLastHurt = -999;
const PLAYER_INVULN = 1.0;

function updatePlayer(delta){
  // input (keyboard)
  // simple WASD
  // event listeners set at bottom
  const elapsed = clock.getElapsedTime();
  let moveSpeed = PLAYER_BASE_SPEED;
  if (player.userData && player.userData.slowUntil && elapsed < player.userData.slowUntil){
    moveSpeed *= 0.45;
  }
  const velocity = new THREE.Vector3();
  if (move.forward !== 0) {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0; dir.normalize();
    velocity.add(dir.multiplyScalar(move.forward));
  }
  if (move.right !== 0){
    const right = new THREE.Vector3();
    camera.getWorldDirection(right);
    right.y = 0;
    right.normalize();
    // right vector:
    right.cross(camera.up);
    velocity.add(right.multiplyScalar(move.right));
  }
  if (velocity.length() > 0) {
    velocity.normalize();
    player.position.add(velocity.multiplyScalar(moveSpeed * delta));
    camera.position.copy(player.position).add(new THREE.Vector3(0,1.6,0));
  } else {
    camera.position.copy(player.position).add(new THREE.Vector3(0,1.6,0));
  }

  // limit area
  player.position.x = THREE.MathUtils.clamp(player.position.x, -49, 49);
  player.position.z = THREE.MathUtils.clamp(player.position.z, -49, 49);
}

// ------------------- Ã‡ARPIÅžMA / ETKÄ°LEÅžÄ°M -------------------
function checkCollisions(){
  const elapsed = clock.getElapsedTime();

  // enemies -> player
  enemies.forEach(enemy => {
    const dist = enemy.position.distanceTo(player.position);
    if (dist < 1.4){
      if (elapsed - playerLastHurt > PLAYER_INVULN && elapsed - enemy.userData.lastAttack > enemy.userData.attackCooldown){
        let damage = enemy.userData.damage;
        damage = Math.round(damage * (1 + gemsCollected/100)); // zorluk faktÃ¶rÃ¼
        health -= damage;
        enemy.userData.lastAttack = elapsed;
        playerLastHurt = elapsed;
        if (sounds.damage) { sounds.damage.setVolume(0.9); sounds.damage.play(); }
        updateUI();
        if (health <= 0) gameOver();
      }
    }
  });

  // trees -> hazard zone (ilk giriÅŸte hasar + yavaÅŸlama)
  trees.forEach(tree => {
    const dist = tree.position.distanceTo(player.position);
    if (!tree.userData._playerInside && dist < 2.0){
      tree.userData._playerInside = true;
      const elapsed = clock.getElapsedTime();
      health -= 6;
      if (!player.userData) player.userData = {};
      player.userData.slowUntil = elapsed + 2.0;
      if (sounds.damage) { sounds.damage.setVolume(0.6); sounds.damage.play(); }
      updateUI();
      if (health <= 0) gameOver();
    } else if (tree.userData._playerInside && dist >= 2.4){
      tree.userData._playerInside = false;
    }
  });

  // gems -> collect
  for (let i = gems.length -1; i >= 0; i--){
    const g = gems[i];
    if (g.position.distanceTo(player.position) < 1.2){
      gemsCollected += g.userData.value || 4;
      scene.remove(g);
      gems.splice(i,1);
      if (sounds.gemCollect) { sounds.gemCollect.setVolume(0.9); sounds.gemCollect.play(); }
      updateUI();
      if (gemsCollected >= WIN_SCORE) gameWon();
    }
  }
}

// ------------------- OYUN SONU / GALÄ°BÄ°YET -------------------
function gameWon(){
  statusEl.textContent = 'KazandÄ±n! ðŸŽ‰';
  isRunning = false;
  if (sounds.win) sounds.win.play();
  // pointer unlock to allow user to restart
  controls.unlock();
}

function gameOver(){
  statusEl.textContent = 'Oyunu kaybettin.';
  isRunning = false;
  if (sounds
